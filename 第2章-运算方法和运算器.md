# 第2章-运算方法和运算器

## 1. 数据表示

### 定点数

<center>
    <img src=".assets/image-20200530185853218.png" alt="image-20200530185853218" style="zoom:100%;" />
</center>

定点小数范围：$-1<X<1$

定点整数范围：$-(2^n-1)\le X\le (2^n-1)$

<center>
    <img src=".assets/image-20200530190029753.png" alt="image-20200530190029753" style="zoom:67%;" />
</center>



### 浮点数

<center>
    <img src=".assets/image-20200530190150016.png" alt="image-20200530190150016" style="zoom:67%;" />
</center>

#### IEEE754标准

<center>
    <img src=".assets/image-20200530190302556.png" alt="image-20200530190302556" style="zoom:67%;" />
</center>

其中，$S$是浮点数的**符号位**，0为正数，1为负数；$M$是**位数**，小数点放在尾数域最左有效位的右边；$E$是**阶码**，用移码方式表示指数

因此，一个规格化的浮点数$X$的**真值**为：
$$
32位：X=(-1)^S\times (1.M)\times 2^{E-127},\ e=E-127\\
64位：X=(-1)^S\times (1.M)\times 2^{E-1023},\ e=E-1023
$$


### 机器码

|      |        原码         |           反码            |              补码              |             移码             |
| :--: | :-----------------: | :-----------------------: | :----------------------------: | :--------------------------: |
| 正数 | 符号位为0，其余不变 |        与原码相同         |           与原码相同           | 数值位与补码相同，符号位相反 |
| 负数 | 符号位为1，其余不变 | 符号位为1，数值位按位取反 | 符号位为1，数值位按位取反后加1 | 数值位与补码相同，符号位相反 |



### 校验码

奇校验位：$\overline C=x_0\oplus x_1\oplus\dots\oplus x_{n-1}$

偶校验位：$ C=x_0\oplus x_1\oplus\dots\oplus x_{n-1}$

$\oplus$代表按位加，当$X$中包含奇数个1时，奇校验位$\overline C=1$，即$C=0$；当$X$中包含偶数个1时，偶校验位$C=0$

假设一个字$X$从$A$从到$B$，在源点$A$可以计算出校验位，然后一起将$(x_0x_1\dots x_{n-1}C)$送到$B$。假设$B$点真正接收到的$X=(x_0'x_1'\dots x_{n-1}' C')$，然后计算
$$
F=x_0'\oplus x_1'\oplus\cdots\oplus x_{n-1}' \oplus C'
$$
若$F=1$，则表明收到的信息有误

- 奇偶校验提供**奇数个错误检测**，无法检测偶数个错误，更无法识别错误信息的位置



## 2. 定点加法、减法运算

### 补码加法

$$
[x+y]_{补}=[x]_补+[y]_补\ (mod\ 2^{n+1})
$$

- 符号位要作为数的一部分一起参加运算
- 要在模$2^{n+1}$意义下相加，查过的进位要丢掉

> <center>
>     <img src=".assets/image-20200530195323628.png" alt="image-20200530195323628" style="zoom:67%;" />
> </center>



### 补码减法

$$
[x-y]_{补}=[x]_{补}-[y]_{补}=[x]_{补}+[-y]_{补}
$$

- 从$[y]_{补}$求$[-y]_{补}$的方法：对$[y]_{补}$包括符号位“求反且最末尾加1”

> <center>
>     <img src=".assets/image-20200530195658022.png" alt="image-20200530195658022" style="zoom:67%;" />
> </center>



### 溢出检测

采用**双符号位法**，此时补码形式为
$$
[x]_{补}=2^{n+2}+x\ (mod\ 2^{n+2})
$$
采用变形补码后，任何正数，两个符号位都是`0`；任何负数，两个符号位都是`1`。如果两个数相加后，其结果的符号位出现`01`或`10`，则表示发生溢出。最高符号位永远表示结果的正确符号

> <center>
>     <img src=".assets/image-20200530201248962.png" alt="image-20200530201248962" style="zoom: 67%;" />
> </center>



## 3. 定点乘法

### 不带符号的阵列乘法器

<center>
    <img src=".assets/image-20200530202001299.png" alt="image-20200530202001299" style="zoom: 80%;" />
</center>

其阵列乘法器逻辑电路如下：

其中，$FA$的斜线方向为进位输出，竖线方向为和输出

<center>
    <img src=".assets/image-20200530202113366.png" alt="image-20200530202113366" style="zoom:80%;" />
</center>



### 带符号的阵列乘法器

如果使用原码乘法，算前求补和算后求补都不需要

如果使用补码乘法，则最终结果需要再一次求补码

<center>
    <img src=".assets/image-20200530203036490.png" alt="image-20200530203036490" style="zoom:80%;" />
</center>

> <center>
>     <img src=".assets/image-20200530204110310.png" alt="image-20200530204110310" style="zoom: 67%;" />
> </center>
>
> <center>
>     <img src=".assets/image-20200530204136195.png" alt="image-20200530204136195" style="zoom:67%;" />
> </center>



## 4. 定点运算器



